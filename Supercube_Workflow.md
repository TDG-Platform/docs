# Supercube GBDX Workflow 

Developer of this workflow: Seth Malitz

This document introduces the Supercube GBDX Workflow and describes how to modify it in order to generate a 16-band aligned AComp supercube from WV3 8-band  VNIR and 8-band DN SWIR digital number (DN) data. The workflow operates on orthorectified or Level 1B imagery. If starting from 1B's, the supercube will be output in a sensible UTM projection. The resulting supercube will be at the VNIR pixel resolution, and its bounding-box extent is that of the overlap of the VNIR and SWIR. The "mi_setup" task within this workflow requires that cloud and water processing be performed. Therefore cloud and water masks are output by this workflow, both at the VNIR resolution and cut to the extent of the supercube. For convenience, an RGB with the extent of the VNIR is also output. 

The outputs generated by this workflow (supercube, cloud mask, and water mask) can be fed directly into a DGLayers workflow. 

**_Supercube Workflow:_** 

```shell
import os
from gbdxtools import Interface
gbdx = Interface()

in_base_dir = "s3://XXXXXXXXXXXX/"
out_base_dir = "s3://XXXXXXXXXXXX/"
print out_base_dir

####### INPUTS #######
input_data_is_1b = True  # True/False 
if input_data_is_1b:
    vnir_reproj_res = "2.0"
    swir_reproj_res = "7.5"
dn_data_dir = os.path.join(in_base_dir, "XXXXXXXXXXXX/") 
dn_vnir_dir = os.path.join(dn_data_dir, "XXXXXXXXXXXX/")
dn_swir_dir = os.path.join(dn_data_dir, "XXXXXXXXXXXX/")
print dn_data_dir

py_script_file = os.path.join(in_base_dir, "PYTHON_SCRIPTS/create_wv3_scube_text_files.py")

####### OUTPUTS #######
out_rgb_dir = os.path.join(out_base_dir, "RGB")
out_scube_dir = os.path.join(out_base_dir, "ACOMP_SCUBE")
out_water_scube_dir = os.path.join(out_base_dir, "WATER_SCUBE")
out_cloud_scube_dir = os.path.join(out_base_dir, "CLOUD_SCUBE")

###### DEBUG OUTPUTS ################
if input_data_is_1b:
    out_acomp_old_dir = os.path.join(out_base_dir, "UTM_ACompOld")
    out_acomp_new_dir = os.path.join(out_base_dir, "UTM_ACompNew")
else:
    out_acomp_old_dir = os.path.join(out_base_dir, "ACOMP_OLD")
    out_acomp_new_dir = os.path.join(out_base_dir, "ACOMP_NEW")

out_vnir_imd_dir = os.path.join(out_base_dir, "vnir_imd_dir")
out_swir_imd_dir = os.path.join(out_base_dir, "swir_imd_dir")
out_cloud_vnir_dir = os.path.join(out_base_dir, "CLOUD_VNIR")
out_water_vnir_dir = os.path.join(out_base_dir, "WATER_VNIR")
out_mi_mask_dir = os.path.join(out_base_dir, "MI_MASK")
out_mi_tmp_dir = os.path.join(out_base_dir, "MI_TMP")

####################################################################################

#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#     Build Water and Cloud Mask -- use old 2015 (default) AC gain offsets          
#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

# Ughli and AComp -- mixing model on. 
if input_data_is_1b:
    ############## Orthorectify 1B and AComp 
    print "Starting with 1B's"
    first_task = gbdx.Task('ughli', 
                        data = dn_vnir_dir, #<---------- VNIR only
                        bands = "Multi",                # Suppress PAN and SWIR processing in orthorectify and reproject
                        exclude_bands = "P, All-S",     # Suppress PAN and SWIR processing in AComp
                        epsg_code = "UTM",
                        pixel_size_ms = vnir_reproj_res,
                        compute_noise = "true") #<------- Generates noise files (which we don't need), but usefully mosaics the output

else: # ortho
    ############## Just do AComp #############
    print "Starting with Ortho's"
    first_task = gbdx.Task("AComp",
                           data = dn_vnir_dir, #<---------- VNIR only
                           compute_noise = "true") #<------- Generates noise files (which we don't need), but usefully mosaics the output

acomp_old_dir = first_task.outputs.data.value

save_acomp_old_task = gbdx.Task('StageDataToS3', 
                    data = acomp_old_dir, 
                    destination = out_acomp_old_dir)

############# Move AComp VNIR to its own directory
cmd = "mv $indir/*-M*_ACOMP.TIF $outdir"
move_vnir_task = gbdx.Task("gdal-cli",
                      command = cmd,
                      data = acomp_old_dir,
                      execution_strategy = 'runonce')

acomp_vnir_old_dir = move_vnir_task.outputs.data.value

############# Make RGB (convenience output)
cmd = "infile=`ls $indir/*.TIF`; "              # Note: back-ticks not single quotes
cmd += 'infname=$(basename "$infile" .TIF); '
cmd += "outfname=$infname'_5_3_2_rgb.tif'; "
cmd += "gdal_translate -b 5 -b 3 -b 2 $indir/*.TIF $outdir/$outfname"   
rgb_task = gbdx.Task("gdal-cli",
                     command = cmd,
                     data = acomp_vnir_old_dir,
                     execution_strategy = 'runonce')

rgb_dir = rgb_task.outputs.data.value 

save_rgb_task = gbdx.Task("StageDataToS3",
                          data = rgb_dir,
                          destination = out_rgb_dir)

############# Water Mask
# Build a water mask boolean raster. water = 255; non-water = 0
water_task = gbdx.Task("protogenV2RAW",
                       raster = acomp_vnir_old_dir)

water_vnir_dir = water_task.outputs.data.value

save_water_vnir_task = gbdx.Task("StageDataToS3",
                            data = water_vnir_dir,
                            destination = out_water_vnir_dir)

############# Cloud Mask
# Build a cloud mask boolean raster. cloud = 255; non-cloud = 0
cloud_task = gbdx.Task("protogenV2RAC",
                       raster = acomp_vnir_old_dir)

cloud_vnir_dir = cloud_task.outputs.data.value

save_cloud_vnir_task = gbdx.Task("StageDataToS3",
                            data = cloud_vnir_dir,
                            destination = out_cloud_vnir_dir)

############# Union Cloud and Water Mask for MI
# NOTE: The output mask file needs a very specific naming convention in order 
# to be ingested by mi_setup task. Here is example of output file name:
# 14AUG28191207-M2AS-054759622010_01_ACOMP_LULC_MASK.tif
cmd = "infile=`ls $indir/dataC/*.tif`; "  # Note: back-ticks not single quotes
cmd += 'infname=$(basename "$infile" .tif); '  
if input_data_is_1b:
    cmd += "infprefix=${infname::34}; "
else:
    cmd += "str=${infname:34:2}; "
    cmd += 'if [ "$str" == "_P" ]; then n=39; else n=34; fi; '
    cmd += "infprefix=${infname::n}; "
cmd += "outfname=$infprefix'_ACOMP_LULC_MASK.tif'; "
cmd += "mkdir $outdir/data; "
cmd += 'gdal_calc.py -A $indir/dataW/*.tif -B $indir/dataC/*.tif --outfile=$outdir/data/$outfname '
cmd += '--calc="numpy.where(B,B,A)" --type=Byte'
union_mask_task = gbdx.Task('gdal-cli-multiplex')
union_mask_task.inputs.dataC = cloud_vnir_dir
union_mask_task.inputs.dataW = water_vnir_dir
union_mask_task.inputs.command = cmd
union_mask_task.execution_strategy='runonce'

mi_mask_dir = union_mask_task.outputs.data.value

save_mi_mask_task = gbdx.Task("StageDataToS3",
                            data = mi_mask_dir,
                            destination = out_mi_mask_dir)

#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#      Build supercube for material ID -- use new 2016 AC gain offsets
#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

# Gain offsets file
acomp_gain_offset_file = "gainOffsetTable_WV3_2016v0.xml" 

# Ughli and AComp -- mixing model on.
if input_data_is_1b:
    ############## Orthorectify 1B and AComp 
    print "Starting with 1B's"
    second_task = gbdx.Task('ughli', 
                        data = dn_vnir_dir, 
                        swir = dn_swir_dir, 
                        bands = "Multi,All-S",    # Suppress PAN processing in orthorectify and reproject
                        exclude_bands = "P",      # Suppress PAN processing in AComp
                        epsg_code = "UTM", 
                        pixel_size_ms = vnir_reproj_res,
                        pixel_size_swir = swir_reproj_res,
                        gain_offset_file = acomp_gain_offset_file,
                        compute_noise = "true")

else: # ortho
    ############## Just do AComp #############
    print "Starting with Ortho's"
    second_task = gbdx.Task("AComp", 
                           data = dn_data_dir,
                           gain_offset_file = acomp_gain_offset_file,
                           compute_noise = "true")

acomp_new_dir = second_task.outputs.data.value

save_acomp_new_task = gbdx.Task('StageDataToS3', 
                    data = acomp_new_dir, 
                    destination = out_acomp_new_dir)

############# Copy IMD's to their own directories
cmd = "mkdir $outdir/dataVimd $outdir/dataSimd; "

cmd += "infile=`ls $indir/data/*-M*.IMD`; "  # Note: back-ticks not single quotes
cmd += 'infname=$(basename "$infile" .IMD); '  
cmd += "infprefix=${infname::${#infname}-6}; " # Strip off "_ACOMP"
cmd += "outfname=$infprefix'.IMD'; "
cmd += "cp $indir/data/*-M*.IMD $outdir/dataVimd/$outfname; "

cmd += "infile=`ls $indir/data/*-A*.IMD`; "  # Note: back-ticks not single quotes
cmd += 'infname=$(basename "$infile" .IMD); '  
cmd += "infprefix=${infname::${#infname}-6}; " # Strip off "_ACOMP"
cmd += "outfname=$infprefix'.IMD'; "
cmd += "cp $indir/data/*-A*.IMD $outdir/dataSimd/$outfname; "

copy_imd_task = gbdx.Task('gdal-cli-multiplex')
copy_imd_task.inputs.data = acomp_new_dir
copy_imd_task.inputs.command = cmd
copy_imd_task.execution_strategy='runonce'

vnir_imd_dir = copy_imd_task.outputs.dataVimd.value
swir_imd_dir = copy_imd_task.outputs.dataSimd.value

save_vnir_imd_task = gbdx.Task("StageDataToS3",
                            data = vnir_imd_dir,
                            destination = out_vnir_imd_dir)

save_swir_imd_task = gbdx.Task("StageDataToS3",
                            data = swir_imd_dir,
                            destination = out_swir_imd_dir)

############# Mutual Information v10
mi_setup_task = gbdx.Task("mi_setup", 
                       vnirPort = vnir_imd_dir,
                       swirPort = swir_imd_dir, 
                       acompPort = acomp_new_dir,
                       classPort = mi_mask_dir, 
                       resamplingKernel = 'nearestNeighbour', # bilinear, bicubic
                       useAComp = True, 
                       lulcMask = True,
                       waterMask = False,
                       cloudMask = False,
                       darkMask = True,
                       buildVrt = True,
                       buildAComp = False,
                       buildClassifier = False,
                       buildMask = True,
                       buildAlignImages = True)

"""
###### TBD Should be doing things this way!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

                       useAComp = "true", 
                       lulcMask = "true",
                       waterMask = "false",
                       cloudMask = "false",
                       darkMask = "true",
                       buildVrt = "true",
                       buildAComp = "false",
                       buildClassifier = "false",
                       buildMask = "true",
                       buildAlignImages = "true")
"""

# Wierd Gregory arguments 
dockerRoot = "/mnt/work/"
mi_setup_task.inputs.vnirDir = os.path.join(dockerRoot, "input/vnirPort")
mi_setup_task.inputs.swirDir = os.path.join(dockerRoot, "input/swirPort")
mi_setup_task.inputs.acompDir = os.path.join(dockerRoot, "input/acompPort")
mi_setup_task.inputs.classDir = os.path.join(dockerRoot, "input/classPort")
mi_setup_task.inputs.outDir = os.path.join(dockerRoot, "output/outPort")
mi_setup_task.inputs.tmpDir = os.path.join(dockerRoot, "output/tmpPort")
mi_setup_task.inputs.statusFile = os.path.join(dockerRoot, "status.json")

# Name EC2 directories
mi_out_dir = mi_setup_task.outputs.outPort.value
mi_tmp_dir = mi_setup_task.outputs.tmpPort.value

############# Stack MI SWIR on MI VNIR 
cmd = "infile=`ls $indir/*-A*.TIF`; "  # Note: back-ticks not single quotes
cmd += 'infname=$(basename "$infile" .TIF); '  
cmd += "infprefix=${infname::34}; "
cmd += "outfname=$infprefix'_ACOMP_SCUBE.TIF'; "
cmd += "gdal_merge.py -separate -o $outdir/$outfname $indir/*-M*.TIF $indir/*-A*.TIF"
stack_task = gbdx.Task("gdal-cli",
                      command = cmd,
                      data = mi_out_dir,
                      execution_strategy = 'runonce')

scube_dir = stack_task.outputs.data.value

save_scube_task = gbdx.Task("StageDataToS3",
                            data = scube_dir,
                            destination = out_scube_dir)

############# Create bands text file and wavelengths text file for Scube 
cmd = "python $indir/create_wv3_scube_text_files.py $outdir"
filegen_task = gbdx.Task("gdal-cli", 
                      command = cmd,
                      data = os.path.dirname(py_script_file), 
                      execution_strategy = 'runonce')

filegen_dir = filegen_task.outputs.data.value

save_filegen_task = gbdx.Task("StageDataToS3",
                           data = filegen_dir,
                           destination = out_scube_dir)

#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#      Cut Water and Cloud Mask to Supercube in prep for DGLayers
#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

# ########### Resample Water Mask to Supercube and cut to the overlap.
rc_water_scube_task = gbdx.Task("resample_and_cut_001",
                    input_A = water_vnir_dir,
                    input_B = scube_dir,
                    nodata_A='-1',
                    r_meth='near',
                    prefixLen='34', # Stops prior to part name
                    osuffA='ACOMP_WATER_MASK')

water_scube_dir = rc_water_scube_task.outputs.out_A.value

save_water_scube_task = gbdx.Task("StageDataToS3",
                            data = water_scube_dir,
                            destination = out_water_scube_dir)

########### Resample Cloud Mask to Supercube and cut to the overlap.
rc_cloud_scube_task = gbdx.Task("resample_and_cut_001",
                    input_A = cloud_vnir_dir,
                    input_B = scube_dir,
                    nodata_A='-1',
                    r_meth='near',
                    prefixLen='34', # Stops prior to part name 
                    osuffA='ACOMP_CLOUD_MASK')

cloud_scube_dir = rc_cloud_scube_task.outputs.out_A.value

save_cloud_scube_task = gbdx.Task("StageDataToS3",
                            data = cloud_scube_dir,
                            destination = out_cloud_scube_dir)

####################################################################################

workflow = gbdx.Workflow([first_task, # <----------- Call to AComp with default gain offsets
                          move_vnir_task,
                          rgb_task,
                          save_rgb_task,
                          water_task,
                          cloud_task,
                          union_mask_task,
                          save_mi_mask_task,
                          second_task, # <---------- Call to AComp with new gain offsets                       
                          copy_imd_task,
                          mi_setup_task,
                          stack_task,
                          save_scube_task,
                          filegen_task,
                          save_filegen_task,
                          rc_water_scube_task, 
                          save_water_scube_task,
                          rc_cloud_scube_task,
                          save_cloud_scube_task]) 

#print workflow.generate_workflow_description()
workflow.execute()
print 
print workflow.id
```

<!--
***************************************************************************
-->

Here are the modifications you need to make to the above workflow for your application:
 
* Set **_in_base_dir_** -- this is the top-level S3 input directory that contains your DN input data 
* Set **_out_base_dir_** -- this is your  top-level S3 output directory
* Set **_input_data_is_1b_** -- (True/False) this indicates whether the input DN data is Level 1B or Orthorectified
* Set **_vnir_reproj_res_** and **_swir_reproj_res_** -- these are the target reprojection resolutions when converting 1B to UTM
* Set **_dn_vnir_dir_** and **_dn_swir_dir_** -- these are the S3 paths of your DN VNIR and DN SWIR input data 
* Set **_dn_data_dir_** -- deepest s3 path that contains both the DN VNIR and DN SWIR input data sub-directories
* Set **_py_script_file_** -- this is the path to a python script that writes band names and wavelengths files for the output supercube

<!--
***************************************************************************
-->

The above workflow calls the following Python script:

**create_wv3_scube_text_files.py:**

```shell
import os
from glob import glob
import argparse

if __name__ == "__main__":

    parser = argparse.ArgumentParser()
    parser.add_argument("outdir")
    args = parser.parse_args()
    outdir = args.outdir

    band_list = ['1_coastal', '2_blue','3_green','4_yellow',
                 '5_red','6_rededge', '7_nir1', '8_nir2',
                 '9_SWIR-1', '10_SWIR-2', '11_SWIR-3', '12_SWIR-4', 
                 '13_SWIR-5', '14_SWIR-6', '15_SWIR-7', '16_SWIR-8'] 

    fobj = open(os.path.join(outdir, "bands.txt"), "w")
    for x in band_list:
        fobj.write(x + "\n")
    fobj.close()

    wave_list = ['427.399994', 
                 '481.899994', 
                 '547.099976', 
                 '604.299988',  
                 '660.099976',  
                 '722.700012', 
                 '824.000000', 
                 '913.599976',  
                 '1209.099976', 
                 '1571.599976', 
                 '1661.099976', 
                 '1729.500000', 
                 '2163.699951',  
                 '2202.199951',  
                 '2259.300049', 
                 '2329.199951']  

    fobj = open(os.path.join(outdir, "wavelengths.txt"), "w")
    for x in wave_list:
        fobj.write(x + "\n")
    fobj.close()
```

<!--
***************************************************************************
-->

**Future Improvements** 

* To improve run-time efficiency, don't compute the reprojection of VNIR 1B twice, as is happening now with the two calls to ughli task
* Incorporate newest protogen tasks for cloud and water masking when they become available
* Incoporate latest resample_and_cut task when it becomes available
* Improve I/F for mi_setup -- it is clunky at the moment. Move filegen_task funcionality inside mi_setup. Provide option to stack. Others.
* Convert StageDataToS3 task to savedata task











