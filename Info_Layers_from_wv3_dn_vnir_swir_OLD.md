# Information Layers (from WV3 DN VNIR and SWIR) GBDX Workflow 

Developer of workflow: Seth Malitz

This document introduces the Information Layers GBDX Workflow and describes how to modify it in order to compute a range of derived layers (raster and polygon) by starting with WV3 8-band VNIR and 8-band SWIR digital number (DN) data. The workflow operates on orthorectified or Level 1B imagery. If starting from 1B's, all products will be output in a sensible UTM projection. The output products are: RGB, 16-band aligned AComp "Supercube", water mask, cloud mask, and derived raster/vector layers that are specified from a DGLayers recipe file. DGLayers is a GBDX task called by the workflow. The workflow has essentially two phases: (1) Build AComp supercube, water mask, and cloud mask; (2) Run DGLayers against the supercube, masks, and recipe file. You will observe in the workflow below, that the derived layers generated by DGLayers are written to subdirectories of a single output port called DST_LAYERS. This output port is saved recursively to the desired S3 location.

For more information on DGLayers and recipe files, see[DGLayers] 
(https://github.digitalglobe.com/nw002655/dglayers/blob/master/DGLayers-GBDX.md)

<!--
***************************************************************************
-->

**_Information Layers (from WV3 DN VNIR and SWIR) Workflow:_** 

```shell
import os
from gbdxtools import Interface
gbdx = Interface()

in_base_dir = "s3://XXXXXXXXXXXX/"
out_base_dir = "s3://XXXXXXXXXXXX/"
print out_base_dir

####### INPUTS #######
input_data_is_1b = True  # True/False 
if input_data_is_1b:
    vnir_reproj_res = "2.0"
    swir_reproj_res = "7.5"
dn_data_dir = os.path.join(in_base_dir, "XXXXXXXXXXXX/")
dn_vnir_dir = os.path.join(dn_data_dir, "XXXXXXXXXXXX/")
dn_swir_dir = os.path.join(dn_data_dir, "XXXXXXXXXXXX/")
print dn_data_dir

recipe_dir = os.path.join(in_base_dir, "XXXXXXXXXXXX/")
recipe_filename = "info_layers_dgl_recipe.txt"

py_script_file = os.path.join(in_base_dir, "PYTHON_SCRIPTS/create_wv3_scube_text_files.py")

#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ Do NOT MODIFY BELOW THIS LINE @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

####### OUTPUTS #######
out_rgb_dir = os.path.join(out_base_dir, "RGB")
out_scube_dir = os.path.join(out_base_dir, "ACOMP_SCUBE")
out_water_scube_dir = os.path.join(out_base_dir, "WATER_SCUBE")
out_cloud_scube_dir = os.path.join(out_base_dir, "CLOUD_SCUBE")
out_layers_dir = os.path.join(out_base_dir, "LAYERS")

###### DEBUG OUTPUTS ################
if input_data_is_1b:
    out_acomp_old_dir = os.path.join(out_base_dir, "UTM_ACompOld")
    out_acomp_new_dir = os.path.join(out_base_dir, "UTM_ACompNew")
else:
    out_acomp_old_dir = os.path.join(out_base_dir, "ACOMP_OLD")
    out_acomp_new_dir = os.path.join(out_base_dir, "ACOMP_NEW")

out_vnir_imd_dir = os.path.join(out_base_dir, "vnir_imd_dir")
out_swir_imd_dir = os.path.join(out_base_dir, "swir_imd_dir")
out_cloud_vnir_dir = os.path.join(out_base_dir, "CLOUD_VNIR")
out_water_vnir_dir = os.path.join(out_base_dir, "WATER_VNIR")
out_mi_mask_dir = os.path.join(out_base_dir, "MI_MASK")
out_mi_tmp_dir = os.path.join(out_base_dir, "MI_TMP")

#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#     Build Water and Cloud Mask -- use old 2015 (default) AC gain offsets          
#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

# Ughli and AComp -- mixing model on. 
if input_data_is_1b:
    ############## Orthorectify 1B and AComp 
    print "Starting with 1B's"
    first_task = gbdx.Task('ughli', 
                        data = dn_vnir_dir, #<---------- VNIR only
                        bands = "Multi",                # Suppress PAN and SWIR processing in orthorectify and reproject
                        exclude_bands = "P, All-S",     # Suppress PAN and SWIR processing in AComp
                        epsg_code = "UTM",
                        pixel_size_ms = vnir_reproj_res,
                        compute_noise = "true") #<------- Generates noise files (which we don't need), but usefully mosaics the output

else: # ortho
    ############## Just do AComp #############
    print "Starting with Ortho's"
    first_task = gbdx.Task("AComp",
                           data = dn_vnir_dir, #<---------- VNIR only
                           compute_noise = "true") #<------- Generates noise files (which we don't need), but usefully mosaics the output

acomp_old_dir = first_task.outputs.data.value

save_acomp_old_task = gbdx.Task('StageDataToS3', 
                    data = acomp_old_dir, 
                    destination = out_acomp_old_dir)

############# Move AComp VNIR to its own directory
cmd = "mv $indir/*-M*_ACOMP.TIF $outdir"
move_vnir_task = gbdx.Task("gdal-cli",
                      command = cmd,
                      data = acomp_old_dir,
                      execution_strategy = 'runonce')

acomp_vnir_old_dir = move_vnir_task.outputs.data.value

############# Make RGB (convenience output)
cmd = "infile=`ls $indir/*.TIF`; "              # Note: back-ticks not single quotes
cmd += 'infname=$(basename "$infile" .TIF); '
cmd += "outfname=$infname'_5_3_2_rgb.tif'; "
cmd += "gdal_translate -b 5 -b 3 -b 2 $indir/*.TIF $outdir/$outfname"   
rgb_task = gbdx.Task("gdal-cli",
                     command = cmd,
                     data = acomp_vnir_old_dir,
                     execution_strategy = 'runonce')

rgb_dir = rgb_task.outputs.data.value 

save_rgb_task = gbdx.Task("StageDataToS3",
                          data = rgb_dir,
                          destination = out_rgb_dir)

############# Water Mask
# Build a water mask boolean raster. water = 255; non-water = 0
water_task = gbdx.Task("protogenV2RAW",
                       raster = acomp_vnir_old_dir)

water_vnir_dir = water_task.outputs.data.value

save_water_vnir_task = gbdx.Task("StageDataToS3",
                            data = water_vnir_dir,
                            destination = out_water_vnir_dir)

############# Cloud Mask
# Build a cloud mask boolean raster. cloud = 255; non-cloud = 0
cloud_task = gbdx.Task("protogenV2RAC",
                       raster = acomp_vnir_old_dir)

cloud_vnir_dir = cloud_task.outputs.data.value

save_cloud_vnir_task = gbdx.Task("StageDataToS3",
                            data = cloud_vnir_dir,
                            destination = out_cloud_vnir_dir)

############# Union Cloud and Water Mask for MI
# NOTE: The output mask file needs a very specific naming convention in order 
# to be ingested by mi_setup task. Here is example of output file name:
# 14AUG28191207-M2AS-054759622010_01_ACOMP_LULC_MASK.tif
cmd = "infile=`ls $indir/dataC/*.tif`; "  # Note: back-ticks not single quotes
cmd += 'infname=$(basename "$infile" .tif); '  
if input_data_is_1b:
    cmd += "infprefix=${infname::34}; "
else:
    cmd += "str=${infname:34:2}; "
    cmd += 'if [ "$str" == "_P" ]; then n=39; else n=34; fi; '
    cmd += "infprefix=${infname::n}; "
cmd += "outfname=$infprefix'_ACOMP_LULC_MASK.tif'; "
cmd += "mkdir $outdir/data; "
cmd += 'gdal_calc.py -A $indir/dataW/*.tif -B $indir/dataC/*.tif --outfile=$outdir/data/$outfname '
cmd += '--calc="numpy.where(B,B,A)" --type=Byte'
union_mask_task = gbdx.Task('gdal-cli-multiplex')
union_mask_task.inputs.dataC = cloud_vnir_dir
union_mask_task.inputs.dataW = water_vnir_dir
union_mask_task.inputs.command = cmd
union_mask_task.execution_strategy='runonce'

mi_mask_dir = union_mask_task.outputs.data.value

save_mi_mask_task = gbdx.Task("StageDataToS3",
                            data = mi_mask_dir,
                            destination = out_mi_mask_dir)

#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#      Build supercube for material ID -- use new 2016 AC gain offsets
#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

# Gain offsets file
acomp_gain_offset_file = "gainOffsetTable_WV3_2016v0.xml" 

# Ughli and AComp -- mixing model on.
if input_data_is_1b:
    ############## Orthorectify 1B and AComp 
    print "Starting with 1B's"
    second_task = gbdx.Task('ughli', 
                        data = dn_vnir_dir, 
                        swir = dn_swir_dir, 
                        bands = "Multi,All-S",    # Suppress PAN processing in orthorectify and reproject
                        exclude_bands = "P",      # Suppress PAN processing in AComp
                        epsg_code = "UTM", 
                        pixel_size_ms = vnir_reproj_res,
                        pixel_size_swir = swir_reproj_res,
                        gain_offset_file = acomp_gain_offset_file,
                        compute_noise = "true")

else: # ortho
    ############## Just do AComp #############
    print "Starting with Ortho's"
    second_task = gbdx.Task("AComp", 
                           data = dn_data_dir,
                           gain_offset_file = acomp_gain_offset_file,
                           compute_noise = "true")

acomp_new_dir = second_task.outputs.data.value

save_acomp_new_task = gbdx.Task('StageDataToS3', 
                    data = acomp_new_dir, 
                    destination = out_acomp_new_dir)

############# Copy IMD's to their own directories
cmd = "mkdir $outdir/dataVimd $outdir/dataSimd; "

cmd += "infile=`ls $indir/data/*-M*.IMD`; "  # Note: back-ticks not single quotes
cmd += 'infname=$(basename "$infile" .IMD); '  
cmd += "infprefix=${infname::${#infname}-6}; " # Strip off "_ACOMP"
cmd += "outfname=$infprefix'.IMD'; "
cmd += "cp $indir/data/*-M*.IMD $outdir/dataVimd/$outfname; "

cmd += "infile=`ls $indir/data/*-A*.IMD`; "  # Note: back-ticks not single quotes
cmd += 'infname=$(basename "$infile" .IMD); '  
cmd += "infprefix=${infname::${#infname}-6}; " # Strip off "_ACOMP"
cmd += "outfname=$infprefix'.IMD'; "
cmd += "cp $indir/data/*-A*.IMD $outdir/dataSimd/$outfname; "

copy_imd_task = gbdx.Task('gdal-cli-multiplex')
copy_imd_task.inputs.data = acomp_new_dir
copy_imd_task.inputs.command = cmd
copy_imd_task.execution_strategy='runonce'

vnir_imd_dir = copy_imd_task.outputs.dataVimd.value
swir_imd_dir = copy_imd_task.outputs.dataSimd.value

save_vnir_imd_task = gbdx.Task("StageDataToS3",
                            data = vnir_imd_dir,
                            destination = out_vnir_imd_dir)

save_swir_imd_task = gbdx.Task("StageDataToS3",
                            data = swir_imd_dir,
                            destination = out_swir_imd_dir)

############# Mutual Information v10
mi_setup_task = gbdx.Task("mi_setup", 
                       vnirPort = vnir_imd_dir,
                       swirPort = swir_imd_dir, 
                       acompPort = acomp_new_dir,
                       classPort = mi_mask_dir, 
                       resamplingKernel = 'nearestNeighbour', # bilinear, bicubic
                       useAComp = True, 
                       lulcMask = True,
                       waterMask = False,
                       cloudMask = False,
                       darkMask = True,
                       buildVrt = True,
                       buildAComp = False,
                       buildClassifier = False,
                       buildMask = True,
                       buildAlignImages = True)
					   
# mi_setup can be a memory hog -- set larger domain
mi_setup_task.domain = 'r44xlarge'

"""
###### TBD Should be doing things this way!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

                       useAComp = "true", 
                       lulcMask = "true",
                       waterMask = "false",
                       cloudMask = "false",
                       darkMask = "true",
                       buildVrt = "true",
                       buildAComp = "false",
                       buildClassifier = "false",
                       buildMask = "true",
                       buildAlignImages = "true")
"""

# Wierd Gregory arguments 
dockerRoot = "/mnt/work/"
mi_setup_task.inputs.vnirDir = os.path.join(dockerRoot, "input/vnirPort")
mi_setup_task.inputs.swirDir = os.path.join(dockerRoot, "input/swirPort")
mi_setup_task.inputs.acompDir = os.path.join(dockerRoot, "input/acompPort")
mi_setup_task.inputs.classDir = os.path.join(dockerRoot, "input/classPort")
mi_setup_task.inputs.outDir = os.path.join(dockerRoot, "output/outPort")
mi_setup_task.inputs.tmpDir = os.path.join(dockerRoot, "output/tmpPort")
mi_setup_task.inputs.statusFile = os.path.join(dockerRoot, "status.json")

# Name EC2 directories
mi_out_dir = mi_setup_task.outputs.outPort.value
mi_tmp_dir = mi_setup_task.outputs.tmpPort.value

############# Stack MI SWIR on MI VNIR 
cmd = "infile=`ls $indir/*-A*.TIF`; "  # Note: back-ticks not single quotes
cmd += 'infname=$(basename "$infile" .TIF); '  
cmd += "infprefix=${infname::34}; "
cmd += "outfname=$infprefix'_ACOMP_SCUBE.TIF'; "
cmd += "gdal_merge.py -separate -o $outdir/$outfname $indir/*-M*.TIF $indir/*-A*.TIF"
stack_task = gbdx.Task("gdal-cli",
                      command = cmd,
                      data = mi_out_dir,
                      execution_strategy = 'runonce')

scube_dir = stack_task.outputs.data.value

save_scube_task = gbdx.Task("StageDataToS3",
                            data = scube_dir,
                            destination = out_scube_dir)

############# Create bands text file and wavelengths text file for Scube 
cmd = "python $indir/create_wv3_scube_text_files.py $outdir"
filegen_task = gbdx.Task("gdal-cli", 
                      command = cmd,
                      data = os.path.dirname(py_script_file), 
                      execution_strategy = 'runonce')

filegen_dir = filegen_task.outputs.data.value

save_filegen_task = gbdx.Task("StageDataToS3",
                           data = filegen_dir,
                           destination = out_scube_dir)

#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#      Cut Water and Cloud Mask to Supercube in prep for DGLayers
#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

# ########### Resample Water Mask to Supercube and cut to the overlap.
rc_water_scube_task = gbdx.Task("resample_and_cut_001",
                    input_A = water_vnir_dir,
                    input_B = scube_dir,
                    nodata_A='-1',
                    r_meth='near',
                    prefixLen='34', # Stops prior to part name
                    osuffA='ACOMP_WATER_MASK')

water_scube_dir = rc_water_scube_task.outputs.out_A.value

save_water_scube_task = gbdx.Task("StageDataToS3",
                            data = water_scube_dir,
                            destination = out_water_scube_dir)

########### Resample Cloud Mask to Supercube and cut to the overlap.
rc_cloud_scube_task = gbdx.Task("resample_and_cut_001",
                    input_A = cloud_vnir_dir,
                    input_B = scube_dir,
                    nodata_A='-1',
                    r_meth='near',
                    prefixLen='34', # Stops prior to part name 
                    osuffA='ACOMP_CLOUD_MASK')

cloud_scube_dir = rc_cloud_scube_task.outputs.out_A.value

save_cloud_scube_task = gbdx.Task("StageDataToS3",
                            data = cloud_scube_dir,
                            destination = out_cloud_scube_dir)

#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#                          Call DGLayers 
#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

# SRCXXX is an input symbol in the DGLayers recipe 
layers_task = gbdx.Task("DGLayers",  
                     SRC1_SCUBE = scube_dir, 
                     SRC2_CLOUD = cloud_scube_dir,
                     SRC3_WATER = water_scube_dir,
                     generate_top_dir = 'True',
                     recipe_dir = recipe_dir, 
                     recipe_filename = recipe_filename)
layers_task.domain = 'r44xlarge'
#layers_task.timeout = 36000 				 

layers_dir = layers_task.outputs.DST_LAYERS.value

save_layers_task = gbdx.Task("StageDataToS3",
                          data = layers_dir,
                          destination = out_layers_dir)

####################################################################################

workflow = gbdx.Workflow([first_task, # <----------- Call to AComp with default gain offsets
                          move_vnir_task,
                          rgb_task,
                          save_rgb_task,
                          water_task,
                          cloud_task,
                          union_mask_task,
                          save_mi_mask_task,
                          second_task, # <---------- Call to AComp with new gain offsets                       
                          copy_imd_task,
                          mi_setup_task,
                          stack_task,
                          save_scube_task,
                          filegen_task,
                          save_filegen_task,
                          rc_water_scube_task, 
                          save_water_scube_task,
                          rc_cloud_scube_task,
                          save_cloud_scube_task,
                          layers_task,
                          save_layers_task]) 

#print workflow.generate_workflow_description()
workflow.execute()
print 
print workflow.id
```

<!--
***************************************************************************
-->

Here are the modifications you need to make to the above workflow for your application:
 
* Set **_in_base_dir_** -- this is the top-level S3 input directory that contains your DN input data 
* Set **_out_base_dir_** -- this is your  top-level S3 output directory
* Set **_input_data_is_1b_** -- (True/False) this indicates whether the input DN data is Level 1B or Orthorectified
* Set **_vnir_reproj_res_** and **_swir_reproj_res_** -- these are the target reprojection resolutions when converting 1B to UTM
* Set **_dn_vnir_dir_** and **_dn_swir_dir_** -- these are the S3 paths of your DN VNIR and DN SWIR input data 
* Set **_dn_data_dir_** -- deepest s3 path that contains both the DN VNIR and DN SWIR input data sub-directories
* Set **_recipe_dir_** -- this is the S3 directory that contains your DGLayers recipe file **_and any auxiliary files it refers to_** 
* Set **_recipe_filename_** -- this is the file name of your DGLayers recipe file 
* Set **_py_script_file_** -- this is the path to a python script that writes band names and wavelengths files for the output supercube

<!--
***************************************************************************
-->

The above workflow calls the following Python script:

**create_wv3_scube_text_files.py:**

```shell
import os
from glob import glob
import argparse

if __name__ == "__main__":

    parser = argparse.ArgumentParser()
    parser.add_argument("outdir")
    args = parser.parse_args()
    outdir = args.outdir

    band_list = ['1_coastal', '2_blue','3_green','4_yellow',
                 '5_red','6_rededge', '7_nir1', '8_nir2',
                 '9_SWIR-1', '10_SWIR-2', '11_SWIR-3', '12_SWIR-4', 
                 '13_SWIR-5', '14_SWIR-6', '15_SWIR-7', '16_SWIR-8'] 

    fobj = open(os.path.join(outdir, "bands.txt"), "w")
    for x in band_list:
        fobj.write(x + "\n")
    fobj.close()

    wave_list = ['427.399994', 
                 '481.899994', 
                 '547.099976', 
                 '604.299988',  
                 '660.099976',  
                 '722.700012', 
                 '824.000000', 
                 '913.599976',  
                 '1209.099976', 
                 '1571.599976', 
                 '1661.099976', 
                 '1729.500000', 
                 '2163.699951',  
                 '2202.199951',  
                 '2259.300049', 
                 '2329.199951']  

    fobj = open(os.path.join(outdir, "wavelengths.txt"), "w")
    for x in wave_list:
        fobj.write(x + "\n")
    fobj.close()
```

The above workflow presently calls the following DGLayers recipe file:

**info_layers_dgl_recipe.txt:**

```shell
#########################################################################
###################   DGLayers Recipe File    ##########################
#########################################################################

# Build Mining Layers -- Masked Indices and Masked Class Map
# Assumes the following input symbols:
# 	SRC1_SCUBE -- AComp'd supercube 0 - 10000 uint16 image
# 	SRC2_CLOUD -- cloud mask with 255 = cloud, 0 = non-cloud
# 	SRC3_WATER -- water mask with 255 = water, 0 = non-water

#------------------------------------------------------------------------
#          Optional file symbols must begin with "FILE_" 
#------------------------------------------------------------------------

FILE_1 = WV3_mineral_indices_small.exp
FILE_2 = WV3_mineral_spectra_small.txt

#------------------------------------------------------------------------
#	Optional renaming of output directories and files.
# 	Use sandwiched pair: BEGIN_RENAME_OUTPUTS, END_RENAME_OUTPUTS
#   PREFIX_LEN length of file name prefix from SRC file that will be 
#		used in the file name of corresponding output files
#   Triplets of form: <outdir_id> <outdir_name> <suffix>. Indicates 
#   	that directory <outdir_id> is to be renamed <outdir_name> and 
#		that the file names will involve the suffix string <suffix>
#------------------------------------------------------------------------

BEGIN_RENAME_OUTPUTS
PREFIX_LEN 34
n1i INDICES indices
n1m CLASSMAP classmap
n5s COMBO_MASK comboMask
n3v VEG_POLYS veg_polys
END_RENAME_OUTPUTS

#------------------------------------------------------------------------
#                             Process Flow 
#------------------------------------------------------------------------

#######################
### black fill
#######################

subset_bands --outdirID n1b --indirID SRC1_SCUBE -bands 9
n2b = np.where(n1b == 0, 1, 0).astype(np.bool) 

#######################
### veg mask 
#######################

indices -outdirID n1v -indirID SRC1_SCUBE -indexIDandExp NDVI (B7-B5)/(B7+B5) -noDataValIn 0 -noDataValOut 0 
n2v = np.where(n1v > 0.3, 1, 0).astype(np.bool) 

#######################
### Dark mask 
#######################

indices -outdirID n1d -indirID SRC1_SCUBE -indexIDandExp AVG (B2+B3+B5)/3 -noDataValIn 0 -noDataValOut 0 
n2d = np.where(n1d < 500, 1, 0).astype(np.bool)  

#######################
### Indices 
#######################

# Using the noDataValOut of black fill
indices -outdirID n1i -indirID SRC1_SCUBE -indexIDsFromFile FILE_1 all -noDataValIn -0 -noDataValOut 9999 -deliver

#######################
### Class map
#######################

# Use -rules if want rules file
spec_angle_mapper -outdirID n1m -indirID SRC1_SCUBE -materialIDsFromFile FILE_2 all -defAngThreshRad 0.175 -noDataValIn 0 -noDataValOut 255 -deliver

#######################
### Merge Masks
#######################

### Dark --> 1 
n1s = np.where(n2d, 1, 0).astype(np.uint8) 
### Vegetation --> 2
n2s = np.where(n2v, 2, n1s).astype(np.uint8)
### Water --> 3
n3s = np.where(SRC3_WATER, 3, n2s).astype(np.uint8)
### Cloud --> 4 
n4s = np.where(SRC2_CLOUD, 4, n3s).astype(np.uint8)
### Black fill --> 5
n5s = np.where(n2b, 5, n4s).astype(np.uint8) -deliver

#######################
### Veg Polygons
#######################

polygonize --outdirID n3v --indirID n2v --deliver
```

<!--
***************************************************************************
-->

The above recipe file references the following pair of auxiliary files:

**WV3_mineral_indices_small.exp:**

```shell
# ENVI EXPRESSIONS
B5/B3 : Ferric oxide composition
B11/B13 : Laterite
B11/B5 : Gossan
B11/B7 : Ferric oxide content
(B6 + B9) / B8 : WV3 Ferric Iron, Iron2
B14/B16 : Amphibole
B14/(B15+B16) : WV3 Carbonate Index
```

**WV3_mineral_spectra_small.txt:**

```shell
ENVI ASCII Plot File [Thu Apr 13 22:39:42 2017]
Column 1: X Axis
Column 2: alunite1.spc Alunite GDS84 Na03
Column 3: goethit1.spc Goethite WS222
Column 4: hematit2.spc Hematite GDS27
Column 5: jarosit1.spc Jarosite GDS99 K-y 200C
Column 6: muscovi1.spc Muscovite GDS107
Column 7: kaolini1.spc Kaolinite CM9
Column 8: montmor5.spc Montmorillonite CM27
Column 9: calcite1.spc Calcite WS272
   427.399994  0.487077  0.023342  0.020498  0.148245  0.265378  0.658748  0.570649  0.888164
   481.899994  0.569597  0.037919  0.020564  0.289171  0.440956  0.711892  0.666749  0.932836
   547.099976  0.690354  0.115554  0.033976  0.455857  0.519117  0.750877  0.735990  0.940587
   604.299988  0.779987  0.198295  0.150544  0.571353  0.563403  0.765593  0.758684  0.944833
   660.099976  0.814578  0.207331  0.204799  0.658325  0.602790  0.768714  0.766208  0.946470
   722.700012  0.846923  0.256384  0.292346  0.732752  0.645155  0.775495  0.776951  0.949129
   824.000000  0.857553  0.259180  0.259423  0.545687  0.660149  0.790071  0.776285  0.956332
   913.599976  0.848026  0.227457  0.288944  0.442332  0.657636  0.782465  0.756181  0.958576
  1209.099976  0.861922  0.477551  0.749020  0.595431  0.715096  0.779794  0.762423  0.962938
  1571.599976  0.738906  0.552991  0.833831  0.766949  0.792398  0.791024  0.752381  0.958077
  1661.099976  0.719835  0.534704  0.833675  0.812515  0.798399  0.790810  0.766538  0.955768
  1729.500000  0.637763  0.531958  0.834966  0.804248  0.799671  0.772994  0.753937  0.940535
  2163.699951  0.283338  0.560218  0.822459  0.575042  0.599858  0.363176  0.559239  0.877023
  2202.199951  0.340376  0.545391  0.813539  0.495288  0.425050  0.340700  0.461802  0.881524
  2259.300049  0.521631  0.523693  0.803009  0.439641  0.583838  0.424930  0.537936  0.775606
  2329.199951  0.432153  0.491270  0.788937  0.572383  0.489974  0.355986  0.479090  0.626139
```

<!--
***************************************************************************
-->

To run the workflow on your desired imagery using the above DGLayers recipe file, copy the recipe file and its two auxiliary files (create the files using cut and paste out of this document) to your desired recipe directory on S3, and set the directory paths in the workflow as appropriate.  Copy the python script "create_wv3_scube_text_files.py" to the desired directory on S3, and set the file path appropriately.

**Future Improvements** 

* Compute not only water and cloud mask, but also snow mask
* To improve run-time efficiency, don't compute the reprojection of VNIR 1B twice, as is happening now with the two calls to ughli task
* Incorporate newest protogen tasks for cloud, water, and snow masking when they become available
* Incoporate latest resample_and_cut task when it becomes available
* Improve I/F for mi_setup -- it is clunky at the moment. Move filegen_task funcionality inside mi_setup. Provide option to stack. Others.
* Convert StageDataToS3 task to savedata task












